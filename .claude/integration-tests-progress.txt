# Integration Tests PRD Progress

## Overview
Creating a structured PRD from integration.md to guide implementation of integration tests for the karenina-gui webapp.

## Iteration 1 - 2026-01-10

### Completed
- Read and analyzed integration.md document (4000+ lines)
- Identified existing prd.json is for code refactoring, NOT integration tests
- Created new integration-tests-prd.json with 48 test items

### PRD Structure
- **Total Items**: 48 integration test items
- **Phase 1 (High Priority)**: 9 items (integ-001 to integ-009)
  - File Upload: 3 items
  - Question Extraction: 3 items
  - Template Generation: 3 items
- **Phase 2 (Medium Priority)**: 18 items (integ-010 to integ-024, integ-045 to integ-048)
  - Template Editing: 7 items
  - Configuration: 2 items
  - Preset Management: 2 items
  - Verification: 4 items
  - Results Display: 1 item
  - Benchmark Config: 4 items
- **Phase 3 (Lower Priority)**: 12 items (integ-025 to integ-034, integ-042 to integ-043)
  - Rubric Management: 3 items
  - Database Workflow: 5 items
  - End-to-End: 2 items
  - Additional Features: 2 items
- **Phase 4 (Edge Cases & Accessibility)**: 9 items (integ-035 to integ-041, integ-044)
  - Edge Cases: 5 items
  - Accessibility: 2 items
  - Docs: 1 item (smoke test extension)

### Item Schema
Each PRD item contains:
- `id`: Unique identifier (integ-XXX)
- `category`: Feature area
- `priority`: high/medium/low
- `phase`: 1-4
- `test_file`: Target test file path
- `description`: What the test covers
- `scenarios`: List of specific test scenarios
- `mocks_required`: API mocks needed
- `fixtures_needed`: Fixture files required
- `store_assertions`: Zustand store state to verify
- `status`: pending/in_progress/completed
- `depends_on`: Dependencies on other items
- `effort_estimate`: small/medium/large

### Effort Distribution
- Small: 32 items (~1-2 hours each)
- Medium: 14 items (~2-4 hours each)
- Large: 2 items (~4-8 hours each)

### Next Steps for Iteration 2
1. Review PRD items for completeness
2. Cross-reference with integration.md to ensure no gaps
3. Validate fixture requirements
4. Consider adding more edge cases if needed

## Iteration 2 - 2026-01-10

### Completed
- Cross-referenced PRD with integration.md using grep to find all scenarios
- Identified 11 missing items from original PRD
- Added 11 new items (integ-049 to integ-059)

### Missing Items Added
1. **integ-049**: Few-shot examples configuration (9.3 in integration.md)
2. **integ-050**: Merge results dialog (9.4)
3. **integ-051**: Trace highlighting configuration (9.5)
4. **integ-052**: Generation with different model configs (1.3)
5. **integ-053**: Drill-down from summary statistics (3.4)
6. **integ-054**: Delete benchmark from database (6.2)
7. **integ-055**: Screen reader compatibility (11.1)
8. **integ-056**: Preset application and verification (8.3)
9. **integ-057**: All docs sections accessible (4.1)
10. **integ-058**: Generate templates for many questions (10.1)
11. **integ-059**: Extra kwargs modal configuration (3.1)

### Updated PRD Summary
- **Total Items**: 59 integration test items (was 48)
- **Phase 1 (High Priority)**: 9 items
- **Phase 2 (Medium Priority)**: 21 items (was 18, +3)
- **Phase 3 (Lower Priority)**: 17 items (was 12, +5)
- **Phase 4 (Edge Cases)**: 12 items (was 9, +3)

### Effort Distribution (Updated)
- Small: 41 items (~1-2 hours each)
- Medium: 16 items (~2-4 hours each)
- Large: 2 items (~4-8 hours each)

### Next Steps for Iteration 3
1. Validate JSON structure is valid
2. Review for any remaining gaps
3. Add fixture file specifications where missing
4. Consider splitting any "large" items into smaller ones

## Notes
- PRD file location: karenina-gui/integration-tests-prd.json
- Source document: karenina-gui/integration.md
- Each item represents roughly equal "effort" for implementation
- Items are self-contained with clear dependencies

## Iteration 3 - 2026-01-10

### Completed
- Implemented **integ-001**: CSV file upload and preview display
  - Created integration test file: `src/__tests__/integration/features/file-upload.test.tsx`
  - Created fixture file: `src/test-utils/fixtures/file-upload/csv-preview.json`
  - Implemented 9 test cases covering all scenarios from PRD
  - All tests passing (1194 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-001
1. Upload CSV file via file input and display preview
2. Upload CSV file via drag-and-drop and display preview
3. Verify upload API called with FormData
4. Display preview step with column options
5. Display file name and row count correctly
6. Auto-select columns based on common patterns
7. Handle files with no auto-detectable column names
8. Verify useTemplateStore.uploadedFile is set after upload
9. Verify useTemplateStore.currentStep transitions through upload to configure

### Next Steps for Iteration 4
- integ-002: Excel file upload with multiple sheets (depends on integ-001, now unblocked)
- integ-003: File upload error handling (depends on integ-001, now unblocked)
- integ-004: Question extraction (depends on integ-001, now unblocked)

## Iteration 4 - 2026-01-10

### Completed
- Implemented **integ-003**: File upload error handling
  - Added 6 new test cases to existing file-upload.test.tsx
  - Tests for unsupported file type, file too large, network failure, API errors, retry, and dangerous MIME types
  - All 15 tests in file-upload.test.tsx passing (1200 total tests)
  - Linting and type checking passing

### Test Coverage for integ-003
1. Show error message for unsupported file type (PDF)
2. Show error message for file too large (>50MB)
3. Show error message for network failure during upload
4. Show error message for API error response (400)
5. Allow dismissing local error and retry upload
6. Show error for corrupted file (dangerous MIME type)

### Key Implementation Notes
- File validation happens in FileUploader component before API calls
- Error state managed through localError in QuestionExtractor
- ErrorDisplay component shows errors with dismiss option
- Store validation: uploadedFile remains null when validation fails

### Next Steps for Iteration 5
- integ-002: Excel file upload with multiple sheets (high priority, small effort)
- integ-004: Question extraction (high priority, small effort)
- integ-005: Extraction with metadata columns (high priority, depends on integ-004)

## Iteration 5 - 2026-01-10

### Completed
- Implemented **integ-004**: Question extraction from uploaded file
  - Created new test file: `src/__tests__/integration/features/question-extraction.test.tsx`
  - Created fixture file: `src/test-utils/fixtures/extraction/successful-extraction.json`
  - Implemented 6 test cases covering all scenarios from PRD
  - All tests passing (1206 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-004
1. Configure column mappings and extract questions (full workflow)
2. Handle column mapping change before extraction
3. Show extraction error when API fails
4. Disable extract button when columns not selected
5. Verify extractedQuestions has expected count after extraction
6. Verify currentStep transitions to 'visualize' after extraction

### Key Implementation Notes
- Column selection uses `<select>` elements with role="combobox"
- Questions are stored with `question`, `raw_answer`, and `answer_template` fields (QuestionData interface)
- Extraction API receives: file_id, question_column, answer_column, sheet_name, and optional metadata columns
- Error state managed through extractionResult.error
- Successful extraction transitions currentStep to 'visualize'

### Next Steps for Iteration 6
- integ-002: Excel file upload with multiple sheets (high priority, small effort)
- integ-005: Extraction with metadata columns (high priority, depends on integ-004, now unblocked)
- integ-006: Partial extraction with invalid rows (high priority, depends on integ-004, now unblocked)
- integ-007: Template generation workflow (high priority, depends on integ-004, now unblocked)

## Iteration 6 - 2026-01-10

### Completed
- Implemented **integ-005**: Extraction with metadata columns
  - Added 2 new test cases to question-extraction.test.tsx
  - Created fixture file: `src/test-utils/fixtures/extraction/with-metadata.json`
  - All tests passing (1208 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-005
1. Configure metadata column mappings and extract with metadata
2. Verify metadata is attached to each extracted question

### Key Implementation Notes
- Metadata includes: author (name, email, affiliation), URL, and keywords
- Keywords are returned as an array (split by separator)
- The AdvancedExtractionPanel provides UI for configuring metadata columns
- Metadata structure follows Schema.org Person format for authors

### Next Steps for Iteration 7
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-006: Partial extraction with invalid rows (high priority, small effort, depends on integ-004)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-010: Question navigation in curator (medium priority, no dependencies)

## Iteration 7 - 2026-01-10

### Completed
- Implemented **integ-006**: Partial extraction with invalid rows
  - Added 2 new test cases to question-extraction.test.tsx
  - Created fixture file: `src/test-utils/fixtures/extraction/partial-extraction.json`
  - All tests passing (1210 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-006
1. Upload file with some empty/invalid rows and extract questions
2. Verify warning about skipped rows displayed

### Key Implementation Notes
- API response includes `skipped_rows` array with row indices and reasons
- API response includes `warnings` array with user-facing messages
- Extracted questions only include valid rows (skipped rows are not included)
- Question indices in response use original row numbers (e.g., row 3 has index "3")
- Current UI displays "Extraction Complete" and count of successfully extracted questions
- Warnings are captured in extraction result but not prominently displayed in current UI

### Next Steps for Iteration 8
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-010: Question navigation in curator (medium priority, no dependencies)

## Iteration 8 - 2026-01-10

### Completed
- Implemented **integ-010**: Question navigation in curator
  - Created new test file: `src/__tests__/integration/features/template-editing.test.tsx`
  - All tests passing (1215 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-010
1. Load questions into store and display question list/selector
2. Navigate questions using next/previous buttons
3. Verify selected question updates in store
4. Verify template code displays for selected question
5. Disable previous button on first question and next button on last question

### Key Implementation Notes
- CuratorTab uses `useQuestionStore` for state management
- Store state requires: `questionData`, `checkpoint`, `selectedQuestionId`, and `currentTemplate`
- `getQuestionIds()` returns `Object.keys(questionData)`
- `currentTemplate` is the `answer_template` from the checkpoint for the selected question
- Navigation buttons use `handleNavigateToQuestion` which calls `navigateToQuestion` from the store
- Navigation has a 50ms setTimeout delay for scroll restoration (needs to be awaited in tests)
- Button disabled state is controlled by `currentIndex` position in filtered question list

### Next Steps for Iteration 9
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)

## Iteration 9 - 2026-01-10

### Completed
- Implemented **integ-011**: Question search and filter by status
  - Added 6 new test cases to template-editing.test.tsx
  - All tests passing (1221 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-011
1. Search questions by question text
2. Search questions by answer text
3. Clear search and show all questions
4. Filter to show only finished questions
5. Filter to show only unfinished questions
6. Show no results message when search matches nothing

### Key Implementation Notes
- Search input placeholder: "Search by question, answer, or ID..."
- Search filters against: question text, raw_answer, and question ID (case-insensitive)
- Filter dropdown options: "All", "Finished", "Unfinished"
- Filter dropdown is found by selecting option with "Show All" text
- When filter/search changes, component auto-navigates to first matching question
- When no matches, shows "No questions match your search" message (can be multiple elements)
- Filter uses `checkpoint[id].finished` boolean to determine status
- `questionIds` is computed from `allQuestionIds` filtered by search term and filter status

### Next Steps for Iteration 10
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-012: Edit and save template (medium priority, small effort, depends on integ-010)

## Iteration 10 - 2026-01-10

### Completed
- Implemented **integ-012**: Edit and save template
  - Added 3 test cases to template-editing.test.tsx
  - All tests passing (1224 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-012
1. Edit template and save to checkpoint
2. Verify save action persists changes across questions
3. Verify unsaved changes indicator appears

### Key Implementation Notes
- Template editing is done through `useQuestionStore.setCurrentTemplate()`
- Save button is found by filtering `getAllByText('Save')` for BUTTON elements
- Save action calls `saveCurrentTemplate()` from useQuestionStore
- After save, `checkpoint[qid].answer_template` is updated with new template content
- After save, `checkpoint[qid].last_modified` timestamp is updated
- The `currentTemplate` state is the working copy that gets saved to checkpoint
- Form editor tracks unsaved changes via `hasUnsavedFieldChanges` state
- Changes persist when navigating between questions after saving

### Next Steps for Iteration 11
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-013: Session draft persistence (medium priority, small effort, depends on integ-010)
- integ-015: Add new question (medium priority, small effort, depends on integ-010)
- integ-016: Clone and delete question (medium priority, small effort, depends on integ-010)

## Iteration 11 - 2026-01-10

### Completed
- Implemented **integ-047**: Evaluation mode configuration
  - Created new test file: `src/__tests__/integration/features/benchmark-config.test.tsx`
  - Implemented 5 test cases covering all scenarios from PRD
  - All tests passing (1229 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-047
1. Enable rubric and show evaluation mode options
2. Select template and rubric mode
3. Select rubric only mode
4. Disable rubric and hide evaluation mode options
5. Verify correctness checkbox toggles correctly

### Key Implementation Notes
- BenchmarkTab uses `useBenchmarkStore` for evaluation settings state
- Evaluation modes: `template_only`, `template_and_rubric`, `rubric_only`
- When rubric is enabled, evaluation mode radio buttons appear
- The main rubric checkbox is distinguished from the Deep-Judgment "Rubrics" checkbox by its description text "(Qualitative evaluation using defined traits)"
- Created helper function `findRubricCheckbox()` to find the correct checkbox by iterating through all checkboxes and checking label text content
- Both correctness and rubric can be enabled simultaneously

### Next Steps for Iteration 12
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-013: Session draft persistence (medium priority, small effort, depends on integ-010)
- integ-014: Edit rubric in curator (medium priority, small effort, depends on integ-010)
- integ-015: Add new question (medium priority, small effort, depends on integ-010)
- integ-016: Clone and delete question (medium priority, small effort, depends on integ-010)

## Iteration 12 - 2026-01-10

### Completed
- Implemented **integ-013**: Session draft persistence
  - Added 4 new test cases to template-editing.test.tsx
  - All tests passing (1233 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-013
1. Persist draft when switching tabs (unmount/remount)
2. Persist draft when switching questions
3. Clear draft when saved
4. Handle multiple drafts for different questions

### Key Implementation Notes
- Session drafts are stored in `useQuestionStore.sessionDrafts` (Record<string, string>)
- Drafts are auto-saved by a `useEffect` in CuratorTab when `currentTemplate !== checkpointTemplate`
- `setSessionDraft(qid, template)` directly sets a draft for a question
- `hasSessionDraft(qid)` checks if a draft exists for a question
- `navigateToQuestion(qid)` prefers session draft over checkpoint/question data
- `saveCurrentTemplate()` clears the session draft for the saved question
- Drafts persist across component unmount/remount (simulating tab switches)
- Multiple drafts can exist simultaneously for different questions

### Next Steps for Iteration 13
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-014: Revert to original and mark as finished (medium priority, small effort, depends on integ-012)
- integ-015: Add new question (medium priority, small effort, depends on integ-010)
- integ-016: Clone and delete question (medium priority, small effort, depends on integ-010)

## Iteration 13 - 2026-01-10

### Completed
- Implemented **integ-014**: Revert to original and mark as finished
  - Added 3 new test cases to template-editing.test.tsx
  - All tests passing (1236 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-014
1. Revert to original template
2. Toggle finished status (flag as finished / mark as unfinished)
3. Verify finished status persists across navigation

### Key Implementation Notes
- `getOriginalCode()` returns the original_answer_template from checkpoint or questionData
- `setCurrentTemplate()` is used to set the template (for revert, set to original)
- `toggleFinished()` toggles the finished status in the checkpoint
- Finished button text changes between "Flag as Finished" and "Mark as Unfinished"
- Finished status is stored in `checkpoint[qid].finished`
- Finished status persists across navigation between questions
- The CodeEditor component has built-in revert functionality with buttons for "Revert to Original" and "Revert to Saved"

### Next Steps for Iteration 14
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-015: Add new question (medium priority, small effort, depends on integ-010)
- integ-016: Clone and delete question (medium priority, small effort, depends on integ-010)

## Iteration 14 - 2026-01-10

### Completed
- Implemented **integ-015**: Add new question
  - Added 5 new test cases to template-editing.test.tsx
  - All tests passing (1241 total tests across all test files)
  - Linting and type checking passing

### Test Coverage for integ-015
1. Add new question and verify it appears in the list
2. Add new question with generated template
3. Add new question with basic template when none generated
4. Navigate to newly added question
5. Verify new question defaults to unfinished

### Key Implementation Notes
- `addNewQuestion(question, rawAnswer, author?, keywords?, generatedTemplate?)` adds a new question
- Returns a UUID-generated question ID (e.g., "550e8400-e29b-41d4-a716-446655440000")
- New questions are added to both `questionData` and `checkpoint`
- `selectedQuestionId` is automatically set to the new question after adding
- `currentTemplate` is set to the new question's template
- Basic template uses `BaseAnswer` class with import statements
- If no generated template is provided, `generateBasicTemplate()` creates a default one
- New questions default to `finished: false`
- Metadata (author, keywords) are stored in the checkpoint item
- `getQuestionIds()` returns all question IDs including newly added ones

### Next Steps for Iteration 15
- integ-002: Excel file upload with multiple sheets (high priority, small effort, requires sheet selector UI)
- integ-007: Template generation workflow (high priority, medium effort, WebSocket mocking required)
- integ-008: Template generation cancellation (medium priority, small effort, depends on integ-007)
- integ-016: Clone and delete question (medium priority, small effort, depends on integ-010)
