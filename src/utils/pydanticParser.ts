import type {
  PydanticClassDefinition,
  PydanticFieldDefinition,
  PydanticMethod,
  PydanticParseResult,
  PydanticFieldType,
} from '../types';

/**
 * Parse a Pydantic Answer class from Python code string
 * This parser handles the specific format of Answer classes generated by the Karenina system
 */
export function parsePydanticClass(code: string): PydanticParseResult {
  try {
    // Extract class name and base class
    const classMatch = code.match(/class\s+(\w+)\s*\(([^)]+)\)\s*:/);
    if (!classMatch) {
      return {
        success: false,
        error: 'Could not find class definition',
      };
    }

    const className = classMatch[1];
    const baseClass = classMatch[2].trim();

    // Extract imports (looking for specific patterns)
    const imports = extractImports(code);

    // Extract fields
    const fields = extractFields(code);

    // Extract methods
    const methods = extractMethods(code);

    // Extract correct values from model_post_init and populate fields
    extractCorrectValuesIntoFields(fields, methods);

    // Extract docstring if present
    const docstring = extractDocstring(code);

    return {
      success: true,
      classDefinition: {
        className,
        baseClass,
        imports,
        fields,
        methods,
        docstring,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown parsing error',
    };
  }
}

/**
 * Extract imports from the code
 */
function extractImports(code: string): string[] {
  const imports: string[] = [];

  // We'll dynamically determine imports based on code content

  // Check for specific type imports in the code
  if (code.includes('Literal[')) {
    if (!imports.some((imp) => imp.includes('Literal'))) {
      imports.push('from typing import Literal');
    }
  }
  if (code.includes('Optional[')) {
    if (!imports.some((imp) => imp.includes('Optional'))) {
      imports.push('from typing import Optional');
    }
  }
  if (code.includes('List[')) {
    if (!imports.some((imp) => imp.includes('List'))) {
      imports.push('from typing import List');
    }
  }
  if (code.includes('Union[')) {
    if (!imports.some((imp) => imp.includes('Union'))) {
      imports.push('from typing import Union');
    }
  }
  if (code.includes('Set[')) {
    if (!imports.some((imp) => imp.includes('Set'))) {
      imports.push('from typing import Set');
    }
  }
  if (code.includes('datetime')) {
    imports.push('from datetime import datetime');
  }
  if (code.includes('date') && !code.includes('datetime')) {
    imports.push('from datetime import date');
  }

  // Always include BaseAnswer import
  imports.push('from karenina.schemas.answer_class import BaseAnswer');

  return imports;
}

/**
 * Extract field definitions from the class
 */
function extractFields(code: string): PydanticFieldDefinition[] {
  const fields: PydanticFieldDefinition[] = [];

  // First, let's handle multiline field definitions
  // This regex matches field definitions that may span multiple lines
  // We need to properly handle nested parentheses in Field() arguments
  const multilineFieldPattern =
    /^\s{0,4}(\w+)\s*:\s*([^=]+?)\s*=\s*Field\s*\(((?:[^()]|'[^']*'|"[^"]*"|\([^)]*\))*)\)/gms;

  let match;
  while ((match = multilineFieldPattern.exec(code)) !== null) {
    const fieldName = match[1].trim();
    const pythonType = match[2].trim();
    const fieldArgs = match[3];

    // Skip if this is inside a method by checking indentation
    const lineStart = code.lastIndexOf('\n', match.index) + 1;
    const indentMatch = code.substring(lineStart, match.index).match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1].length : 0;

    // Class-level fields should have 0-4 spaces of indentation
    if (indent > 4) {
      continue;
    }

    // Extract description from Field arguments
    // Handle escaped quotes in descriptions (both single and double quoted strings)
    let description: string | undefined;

    // Try double quoted strings first
    let descMatch = fieldArgs.match(/description\s*=\s*"((?:[^"\\]|\\.)*)"/);
    if (descMatch) {
      description = descMatch[1].replace(/\\"/g, '"').replace(/\\\\/g, '\\');
    } else {
      // Try single quoted strings as fallback
      descMatch = fieldArgs.match(/description\s*=\s*'((?:[^'\\]|\\.)*)'/);
      if (descMatch) {
        description = descMatch[1].replace(/\\'/g, "'").replace(/\\\\/g, '\\');
      }
    }

    // Parse the field type
    const fieldType = parsePythonType(pythonType);

    // Check if field is required (no default value other than Field())
    const required = !pythonType.startsWith('Optional[');

    // Extract literal values if it's a Literal type
    const literalValues = extractLiteralValues(pythonType);

    // Extract list item type if it's a List type
    const listItemType = extractListItemType(pythonType);

    fields.push({
      name: fieldName,
      type: fieldType,
      pythonType,
      description,
      required,
      literalValues,
      listItemType,
      defaultValue: undefined, // Will be set by model_post_init
    });
  }

  // Also check for fields without Field() - simple type annotations
  const simpleFieldPattern = /^\s*(\w+)\s*:\s*([^=\n]+?)(?:\s*=\s*([^(\n]+?))?$/gm;

  while ((match = simpleFieldPattern.exec(code)) !== null) {
    const fieldName = match[1].trim();
    const pythonType = match[2].trim();
    const defaultValue = match[3]?.trim();

    // Skip if already found with Field()
    if (fields.some((f) => f.name === fieldName)) {
      continue;
    }

    // Skip special fields
    if (fieldName === 'id' || fieldName === 'correct') {
      continue;
    }

    // Skip if this is inside a method
    const lineStart = code.lastIndexOf('\n', match.index) + 1;
    const indentMatch = code.substring(lineStart, match.index).match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1].length : 0;

    if (indent > 4) {
      continue;
    }

    const fieldType = parsePythonType(pythonType);
    const required = !pythonType.startsWith('Optional[') && !defaultValue;
    const literalValues = extractLiteralValues(pythonType);
    const listItemType = extractListItemType(pythonType);

    fields.push({
      name: fieldName,
      type: fieldType,
      pythonType,
      description: undefined,
      required,
      literalValues,
      listItemType,
      defaultValue: defaultValue === 'None' ? null : defaultValue,
    });
  }

  return fields;
}

/**
 * Parse Python type annotation to our field type
 */
function parsePythonType(pythonType: string): PydanticFieldType {
  const typeStr = pythonType.toLowerCase().trim();

  // Check complex types first (order matters!)
  if (typeStr.startsWith('literal[')) return 'literal';
  if (typeStr.startsWith('list[')) return 'list';
  if (typeStr.startsWith('optional[')) {
    // Handle Optional[List[str]], Optional[str], etc.
    const innerTypeMatch = typeStr.match(/optional\[(.+)\]/);
    if (innerTypeMatch) {
      return parsePythonType(innerTypeMatch[1]);
    }
  }

  // Check simple types last
  if (typeStr.includes('str')) return 'str';
  if (typeStr.includes('int')) return 'int';
  if (typeStr.includes('float')) return 'float';
  if (typeStr.includes('bool')) return 'bool';
  if (typeStr.includes('date')) return 'date';

  // Default to string for unknown types
  return 'str';
}

/**
 * Extract list item type from List[type] annotation
 */
function extractListItemType(pythonType: string): string | undefined {
  const listMatch = pythonType.match(/List\[([^\]]+)\]/i);
  if (listMatch) {
    const itemType = listMatch[1].trim().toLowerCase();
    // Map Python types to our simple types
    if (itemType === 'str') return 'str';
    if (itemType === 'int') return 'int';
    if (itemType === 'float') return 'float';
    if (itemType === 'bool') return 'bool';
    return 'str'; // Default to string
  }
  return undefined;
}

/**
 * Extract literal values from a Literal type annotation
 */
function extractLiteralValues(pythonType: string): string[] | undefined {
  const match = pythonType.match(/Literal\s*\[(.*?)\]/);
  if (!match) return undefined;

  const valuesStr = match[1];
  const values: string[] = [];

  // Split by comma but respect quotes
  const regex = /["']([^"']+)["']/g;
  let valueMatch;
  while ((valueMatch = regex.exec(valuesStr)) !== null) {
    values.push(valueMatch[1]);
  }

  return values.length > 0 ? values : undefined;
}

/**
 * Extract methods from the class
 */
function extractMethods(code: string): PydanticMethod[] {
  const methods: PydanticMethod[] = [];

  // Pattern to match method definitions
  const methodPattern = /^\s{4,}def\s+(\w+)\s*\([^)]*\)[^:]*:\s*\n((?:\s{8,}.*\n)*)/gm;

  let match;
  while ((match = methodPattern.exec(code)) !== null) {
    const methodName = match[1];
    const methodBody = match[0]; // Include the full method definition

    // Check for decorators before the method
    const beforeMethod = code.substring(0, match.index);
    const decoratorMatch = beforeMethod.match(/@(\w+)(?:\([^)]*\))?\s*$/);
    const decorator = decoratorMatch ? decoratorMatch[0].trim() : undefined;

    methods.push({
      name: methodName,
      code: methodBody.trim(),
      decorator,
    });
  }

  return methods;
}

/**
 * Extract docstring from the class
 */
function extractDocstring(code: string): string | undefined {
  // Match triple-quoted strings after class definition
  const docstringPattern = /class\s+\w+[^:]*:\s*\n\s*["']{3}([\s\S]*?)["']{3}/;
  const match = code.match(docstringPattern);

  return match ? match[1].trim() : undefined;
}

/**
 * Extract correct values from model_post_init method and populate into field definitions
 */
function extractCorrectValuesIntoFields(fields: PydanticFieldDefinition[], methods: PydanticMethod[]): void {
  // Find the model_post_init method
  const modelPostInitMethod = methods.find((m) => m.name === 'model_post_init');
  if (!modelPostInitMethod) {
    return; // No model_post_init method found
  }

  const code = modelPostInitMethod.code;

  // Extract correct values from self.correct assignments
  // Pattern 1: self.correct = { "field": value }  (multiple fields)
  const dictPattern = /self\.correct\s*=\s*\{([\s\S]*?)\}/;
  const dictMatch = code.match(dictPattern);

  if (dictMatch) {
    // Multiple field pattern
    const dictContent = dictMatch[1];

    // Use a more robust approach to extract field assignments
    // Match "field_name": followed by any value until next field or end
    const fieldRegex = /"([^"]+)":\s*((?:\[[^\]]*\]|"[^"]*"|'[^']*'|[^,}]+))(?:\s*,)?/g;

    let match;
    while ((match = fieldRegex.exec(dictContent)) !== null) {
      const fieldName = match[1].trim();
      const valueStr = match[2].trim().replace(/,$/, ''); // Remove trailing comma

      // Find the corresponding field and set its correctValue
      const field = fields.find((f) => f.name === fieldName);
      if (field) {
        field.correctValue = parseCorrectValue(valueStr, field.type);
      }
    }
  } else {
    // Pattern 2: self.correct = value  (single field)
    const singlePattern = /self\.correct\s*=\s*(.+)/;
    const singleMatch = code.match(singlePattern);

    if (singleMatch && fields.length === 1) {
      const valueStr = singleMatch[1].trim();
      const field = fields[0];
      field.correctValue = parseCorrectValue(valueStr, field.type);
    }
  }

  // Extract regex patterns from self.regex assignments
  extractRegexPatterns(fields, code);
}

/**
 * Parse a correct value string based on field type
 */
function parseCorrectValue(
  valueStr: string,
  fieldType: PydanticFieldType
): string | number | boolean | string[] | null {
  valueStr = valueStr.trim();

  switch (fieldType) {
    case 'str':
      // Remove quotes
      if (
        (valueStr.startsWith('"') && valueStr.endsWith('"')) ||
        (valueStr.startsWith("'") && valueStr.endsWith("'"))
      ) {
        return valueStr.slice(1, -1);
      }
      return valueStr;

    case 'int':
      return parseInt(valueStr) || 0;

    case 'float':
      return parseFloat(valueStr) || 0.0;

    case 'bool':
      return valueStr.toLowerCase() === 'true';

    case 'list':
      // Parse list: ["item1", "item2"] or ['item1', 'item2']
      if (valueStr.startsWith('[') && valueStr.endsWith(']')) {
        const listContent = valueStr.slice(1, -1).trim();
        if (!listContent) return [];

        // Split by comma and clean up each item
        const items = listContent
          .split(',')
          .map((item) => {
            item = item.trim();
            // Remove quotes if present
            if ((item.startsWith('"') && item.endsWith('"')) || (item.startsWith("'") && item.endsWith("'"))) {
              return item.slice(1, -1);
            }
            return item;
          })
          .filter((item) => item.length > 0);

        return items;
      }
      return [];

    case 'literal':
      // Remove quotes for literal values
      if (
        (valueStr.startsWith('"') && valueStr.endsWith('"')) ||
        (valueStr.startsWith("'") && valueStr.endsWith("'"))
      ) {
        return valueStr.slice(1, -1);
      }
      return valueStr;

    case 'date':
      // Remove quotes for date strings
      if (
        (valueStr.startsWith('"') && valueStr.endsWith('"')) ||
        (valueStr.startsWith("'") && valueStr.endsWith("'"))
      ) {
        return valueStr.slice(1, -1);
      }
      return valueStr;

    default:
      return valueStr;
  }
}

/**
 * Validate a Pydantic class definition
 */
export function validatePydanticClass(classDef: PydanticClassDefinition): string[] {
  const errors: string[] = [];

  // Check class name
  if (!classDef.className) {
    errors.push('Class name is required');
  } else if (!/^[A-Z][a-zA-Z0-9]*$/.test(classDef.className)) {
    errors.push('Class name must start with uppercase and contain only letters and numbers');
  }

  // Check fields
  const fieldNames = new Set<string>();
  for (const field of classDef.fields) {
    // Check field name
    if (!field.name) {
      errors.push('Field name is required');
    } else if (!/^[a-z_][a-zA-Z0-9_]*$/.test(field.name)) {
      errors.push(`Invalid field name: ${field.name}. Must be valid Python identifier`);
    } else if (fieldNames.has(field.name)) {
      errors.push(`Duplicate field name: ${field.name}`);
    } else {
      fieldNames.add(field.name);
    }

    // Check literal values
    if (field.type === 'literal' && (!field.literalValues || field.literalValues.length === 0)) {
      errors.push(`Literal field ${field.name} must have at least one value`);
    }
  }

  // Check required methods
  const methodNames = classDef.methods.map((m) => m.name);
  if (!methodNames.includes('model_post_init')) {
    errors.push('model_post_init method is required');
  }
  if (!methodNames.includes('verify')) {
    errors.push('verify method is required');
  }

  // Check verify_granular for multiple fields
  if (classDef.fields.length > 1 && !methodNames.includes('verify_granular')) {
    errors.push('verify_granular method is required when there are multiple fields');
  }

  return errors;
}

/**
 * Extract regex patterns from self.regex assignments in model_post_init
 */
function extractRegexPatterns(fields: PydanticFieldDefinition[], code: string): void {
  // Look for self.regex = { ... } pattern
  const regexPattern = /self\.regex\s*=\s*\{([\s\S]*?)\}/;
  const regexMatch = code.match(regexPattern);

  if (!regexMatch) {
    return; // No regex patterns found
  }

  const regexContent = regexMatch[1];

  // Extract each regex field: "name": { "pattern": "...", "expected": "...", "match_type": "..." }
  // Handle both cases: fields with closing braces and fields that end at the parent's closing brace
  const regexFieldPattern = /"([^"]+)":\s*\{([\s\S]*?)(?:\}(?:\s*,)?|$)/g;

  let match;
  while ((match = regexFieldPattern.exec(regexContent)) !== null) {
    const fieldName = match[1].trim();
    const fieldContent = match[2];

    // Extract individual properties within the regex field
    const patternMatch = fieldContent.match(/"pattern":\s*r?"([^"]+)"/);
    const expectedMatch = fieldContent.match(/"expected":\s*([^,}]+)/);
    const matchTypeMatch = fieldContent.match(/"match_type":\s*"([^"]+)"/);

    if (patternMatch) {
      // Create a regex field definition
      const regexField: PydanticFieldDefinition = {
        name: fieldName,
        type: 'regex',
        pythonType: '', // Not used for regex fields
        required: false, // Not used for regex fields
        regexPattern: patternMatch[1],
        regexExpected: parseRegexExpected(expectedMatch ? expectedMatch[1].trim() : ''),
        regexMatchType: (matchTypeMatch ? matchTypeMatch[1] : 'exact') as 'exact' | 'contains' | 'count' | 'all',
      };

      fields.push(regexField);
    }
  }
}

/**
 * Parse regex expected value from string
 */
function parseRegexExpected(expectedStr: string): string | number | string[] {
  expectedStr = expectedStr.replace(/,$/, ''); // Remove trailing comma

  if (expectedStr.startsWith('[') && expectedStr.endsWith(']')) {
    // Parse array
    try {
      return JSON.parse(expectedStr);
    } catch {
      // Fallback parsing for arrays
      const items = expectedStr
        .slice(1, -1)
        .split(',')
        .map(
          (item) => item.trim().replace(/^["']|["']$/g, '') // Remove quotes
        );
      return items;
    }
  } else if (expectedStr.match(/^\d+$/)) {
    // Parse number
    return parseInt(expectedStr, 10);
  } else {
    // Parse string (remove quotes)
    return expectedStr.replace(/^["']|["']$/g, '');
  }
}
