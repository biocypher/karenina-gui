import type {
  PydanticClassDefinition,
  PydanticFieldDefinition,
  PydanticMethod,
  PydanticParseResult,
  PydanticFieldType,
} from '../types';

/**
 * Parse a Pydantic Answer class from Python code string
 * This parser handles the specific format of Answer classes generated by the Karenina system
 */
export function parsePydanticClass(code: string): PydanticParseResult {
  try {
    // Extract class name and base class
    const classMatch = code.match(/class\s+(\w+)\s*\(([^)]+)\)\s*:/);
    if (!classMatch) {
      return {
        success: false,
        error: 'Could not find class definition',
      };
    }

    const className = classMatch[1];
    const baseClass = classMatch[2].trim();

    // Extract imports (looking for specific patterns)
    const imports = extractImports(code);

    // Extract fields
    const fields = extractFields(code);

    // Extract methods
    const methods = extractMethods(code);

    // Extract docstring if present
    const docstring = extractDocstring(code);

    return {
      success: true,
      classDefinition: {
        className,
        baseClass,
        imports,
        fields,
        methods,
        docstring,
      },
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown parsing error',
    };
  }
}

/**
 * Extract imports from the code
 */
function extractImports(code: string): string[] {
  const imports: string[] = [];

  // We'll dynamically determine imports based on code content

  // Check for specific type imports in the code
  if (code.includes('Literal[')) {
    if (!imports.some((imp) => imp.includes('Literal'))) {
      imports.push('from typing import Literal');
    }
  }
  if (code.includes('Optional[')) {
    if (!imports.some((imp) => imp.includes('Optional'))) {
      imports.push('from typing import Optional');
    }
  }
  if (code.includes('List[')) {
    if (!imports.some((imp) => imp.includes('List'))) {
      imports.push('from typing import List');
    }
  }
  if (code.includes('Union[')) {
    if (!imports.some((imp) => imp.includes('Union'))) {
      imports.push('from typing import Union');
    }
  }
  if (code.includes('Set[')) {
    if (!imports.some((imp) => imp.includes('Set'))) {
      imports.push('from typing import Set');
    }
  }
  if (code.includes('datetime')) {
    imports.push('from datetime import datetime');
  }
  if (code.includes('date') && !code.includes('datetime')) {
    imports.push('from datetime import date');
  }

  // Always include BaseAnswer import
  imports.push('from karenina.schemas.answer_class import BaseAnswer');

  return imports;
}

/**
 * Extract field definitions from the class
 */
function extractFields(code: string): PydanticFieldDefinition[] {
  const fields: PydanticFieldDefinition[] = [];

  // First, let's handle multiline field definitions
  // This regex matches field definitions that may span multiple lines
  const multilineFieldPattern = /^\s{0,4}(\w+)\s*:\s*([^=]+?)\s*=\s*Field\s*\(([^)]*)\)/gms;

  let match;
  while ((match = multilineFieldPattern.exec(code)) !== null) {
    const fieldName = match[1].trim();
    const pythonType = match[2].trim();
    const fieldArgs = match[3];

    // Skip if this is inside a method by checking indentation
    const lineStart = code.lastIndexOf('\n', match.index) + 1;
    const indentMatch = code.substring(lineStart, match.index).match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1].length : 0;

    // Class-level fields should have 0-4 spaces of indentation
    if (indent > 4) {
      continue;
    }

    // Extract description from Field arguments
    const descMatch = fieldArgs.match(/description\s*=\s*["']([^"']+)["']/);
    const description = descMatch ? descMatch[1] : undefined;

    // Parse the field type
    const fieldType = parsePythonType(pythonType);

    // Check if field is required (no default value other than Field())
    const required = !pythonType.startsWith('Optional[');

    // Extract literal values if it's a Literal type
    const literalValues = extractLiteralValues(pythonType);

    fields.push({
      name: fieldName,
      type: fieldType,
      pythonType,
      description,
      required,
      literalValues,
      defaultValue: undefined, // Will be set by model_post_init
    });
  }

  // Also check for fields without Field() - simple type annotations
  const simpleFieldPattern = /^\s*(\w+)\s*:\s*([^=\n]+?)(?:\s*=\s*([^(\n]+?))?$/gm;

  while ((match = simpleFieldPattern.exec(code)) !== null) {
    const fieldName = match[1].trim();
    const pythonType = match[2].trim();
    const defaultValue = match[3]?.trim();

    // Skip if already found with Field()
    if (fields.some((f) => f.name === fieldName)) {
      continue;
    }

    // Skip special fields
    if (fieldName === 'id' || fieldName === 'correct') {
      continue;
    }

    // Skip if this is inside a method
    const lineStart = code.lastIndexOf('\n', match.index) + 1;
    const indentMatch = code.substring(lineStart, match.index).match(/^(\s*)/);
    const indent = indentMatch ? indentMatch[1].length : 0;

    if (indent > 4) {
      continue;
    }

    const fieldType = parsePythonType(pythonType);
    const required = !pythonType.startsWith('Optional[') && !defaultValue;
    const literalValues = extractLiteralValues(pythonType);

    fields.push({
      name: fieldName,
      type: fieldType,
      pythonType,
      description: undefined,
      required,
      literalValues,
      defaultValue: defaultValue === 'None' ? null : defaultValue,
    });
  }

  return fields;
}

/**
 * Parse Python type annotation to our field type
 */
function parsePythonType(pythonType: string): PydanticFieldType {
  const typeStr = pythonType.toLowerCase().trim();

  if (typeStr.includes('str')) return 'str';
  if (typeStr.includes('int')) return 'int';
  if (typeStr.includes('float')) return 'float';
  if (typeStr.includes('bool')) return 'bool';
  if (typeStr.includes('date')) return 'date';
  if (typeStr.startsWith('literal[')) return 'literal';
  if (typeStr.startsWith('list[')) return 'list';
  if (typeStr.startsWith('set[')) return 'set';
  if (typeStr.startsWith('optional[')) return 'optional';
  if (typeStr.startsWith('union[')) return 'union';

  // Default to string for unknown types
  return 'str';
}

/**
 * Extract literal values from a Literal type annotation
 */
function extractLiteralValues(pythonType: string): string[] | undefined {
  const match = pythonType.match(/Literal\s*\[(.*?)\]/);
  if (!match) return undefined;

  const valuesStr = match[1];
  const values: string[] = [];

  // Split by comma but respect quotes
  const regex = /["']([^"']+)["']/g;
  let valueMatch;
  while ((valueMatch = regex.exec(valuesStr)) !== null) {
    values.push(valueMatch[1]);
  }

  return values.length > 0 ? values : undefined;
}

/**
 * Extract methods from the class
 */
function extractMethods(code: string): PydanticMethod[] {
  const methods: PydanticMethod[] = [];

  // Pattern to match method definitions
  const methodPattern = /^\s{4,}def\s+(\w+)\s*\([^)]*\)[^:]*:\s*\n((?:\s{8,}.*\n)*)/gm;

  let match;
  while ((match = methodPattern.exec(code)) !== null) {
    const methodName = match[1];
    const methodBody = match[0]; // Include the full method definition

    // Check for decorators before the method
    const beforeMethod = code.substring(0, match.index);
    const decoratorMatch = beforeMethod.match(/@(\w+)(?:\([^)]*\))?\s*$/);
    const decorator = decoratorMatch ? decoratorMatch[0].trim() : undefined;

    methods.push({
      name: methodName,
      code: methodBody.trim(),
      decorator,
    });
  }

  return methods;
}

/**
 * Extract docstring from the class
 */
function extractDocstring(code: string): string | undefined {
  // Match triple-quoted strings after class definition
  const docstringPattern = /class\s+\w+[^:]*:\s*\n\s*["']{3}([\s\S]*?)["']{3}/;
  const match = code.match(docstringPattern);

  return match ? match[1].trim() : undefined;
}

/**
 * Validate a Pydantic class definition
 */
export function validatePydanticClass(classDef: PydanticClassDefinition): string[] {
  const errors: string[] = [];

  // Check class name
  if (!classDef.className) {
    errors.push('Class name is required');
  } else if (!/^[A-Z][a-zA-Z0-9]*$/.test(classDef.className)) {
    errors.push('Class name must start with uppercase and contain only letters and numbers');
  }

  // Check fields
  const fieldNames = new Set<string>();
  for (const field of classDef.fields) {
    // Check field name
    if (!field.name) {
      errors.push('Field name is required');
    } else if (!/^[a-z_][a-zA-Z0-9_]*$/.test(field.name)) {
      errors.push(`Invalid field name: ${field.name}. Must be valid Python identifier`);
    } else if (fieldNames.has(field.name)) {
      errors.push(`Duplicate field name: ${field.name}`);
    } else {
      fieldNames.add(field.name);
    }

    // Check literal values
    if (field.type === 'literal' && (!field.literalValues || field.literalValues.length === 0)) {
      errors.push(`Literal field ${field.name} must have at least one value`);
    }
  }

  // Check required methods
  const methodNames = classDef.methods.map((m) => m.name);
  if (!methodNames.includes('model_post_init')) {
    errors.push('model_post_init method is required');
  }
  if (!methodNames.includes('verify')) {
    errors.push('verify method is required');
  }

  // Check verify_granular for multiple fields
  if (classDef.fields.length > 1 && !methodNames.includes('verify_granular')) {
    errors.push('verify_granular method is required when there are multiple fields');
  }

  return errors;
}
